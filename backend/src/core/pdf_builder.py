# backend/src/core/pdf_builder.py
# -*- coding: utf-8 -*-
"""
Resilient PDF builder for mock exam papers with uniform line sizing.

- Coalesces multi-line math blocks (\[...\], \(...\), $$...$$).
- Renders math as baseline-aligned images; auto-fits width; slight horizontal condense.
- Conservative math-line stitcher prevents vertical stacks WITHOUT touching normal sentences.
- OCR junk normalization (• · × −) → LaTeX-safe (square→π disabled by default).
- Only “unsquashes” when a line is pure letters with ZERO spaces (very safe).
- Non-math $...$ / \(...\) print as text.
- Multiple fallbacks; temp images cleaned after build.

Small, targeted improvements:
- Fractions render slightly taller for readability (still within 16pt leading).
- Gentle punctuation de-stick for plain text lines (adds missing spaces in a few cases).
"""

from typing import Optional, List, Union
from pathlib import Path
import os, re, tempfile

from reportlab.lib.pagesizes import A4
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, PageBreak,
    Flowable
)
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_RIGHT
from reportlab.lib import colors
from reportlab.lib.utils import ImageReader

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

# Optional LaTeX sniff
try:
    from sympy.parsing.latex import parse_latex
    HAS_SYMPY = True
except Exception:
    HAS_SYMPY = False


# ---------------- TUNABLES ----------------
JOIN_MATH_RUNS_MODE = "strict"     # "off" | "strict" | "loose"
REQUIRE_OPERATOR_FOR_BLOCK = True  # if True a block line must contain an operator/LaTeX cmd
NORMALIZE_SQUARE_TO_PI = False     # if True: "■"/"□" -> \pi
ENABLE_UNSQUASH_SAFE = True        # fix only long alpha blobs with zero spaces

# Visual
MATH_H_SHRINK = 0.86               # horizontal condense (0.82..0.92 typical)

# ---------------- Layout constants ----------------
LEFT_MARGIN  = 54
RIGHT_MARGIN = 54
TOP_MARGIN   = 60
BOTTOM_MARGIN= 60
USABLE_WIDTH = A4[0] - LEFT_MARGIN - RIGHT_MARGIN

# Typography (UNIFORM)
BASE_FONTSIZE = 12
BASE_LEADING  = 16
MATH_IMG_H    = 12                 # default inline/block math height (pt)
MATH_IMG_H_FRAC = 14               # slightly taller for fractions (<= BASE_LEADING)

# ---------------- Palette ----------------
ACCENT = colors.HexColor("#1f7aed")
SECTION = colors.HexColor("#6b5b95")
OK_GREEN = colors.HexColor("#1e9e62")
SOFT_GREY = colors.HexColor("#555555")
HAIRLINE = colors.HexColor("#DDDDDD")
LIGHT_GREEN_BG = colors.HexColor("#e6f9f0")

# ---------------- Styles ----------------
styles = getSampleStyleSheet()
style_cover_title = ParagraphStyle("CoverTitle", parent=styles["Title"],
    fontSize=24, leading=30, alignment=1, spaceAfter=16)  # 1=center
style_cover_sub = ParagraphStyle("CoverSub", parent=styles["Normal"],
    fontSize=12, leading=16, alignment=1, textColor=SOFT_GREY, spaceAfter=8)

style_body = ParagraphStyle("Body", parent=styles["Normal"],
    fontSize=BASE_FONTSIZE, leading=BASE_LEADING, spaceAfter=0)
style_question = ParagraphStyle("Question", parent=style_body, spaceBefore=0, spaceAfter=0)
style_option   = ParagraphStyle("Option",   parent=style_body, leftIndent=24, spaceAfter=0)
style_answer   = ParagraphStyle("Answer",   parent=style_body, leftIndent=18,
                                backColor=LIGHT_GREEN_BG, textColor=OK_GREEN,
                                spaceBefore=0, spaceAfter=0)
style_marks    = ParagraphStyle("Marks",    parent=style_body, alignment=TA_RIGHT,
                                textColor=SOFT_GREY, spaceBefore=0, spaceAfter=0)

# ---------------- Footer & Header ----------------
def _footer(canvas, doc):
    canvas.saveState()
    canvas.setStrokeColor(HAIRLINE); canvas.setLineWidth(0.5)
    canvas.line(50, 52, A4[0]-50, 52)
    canvas.setFont("Helvetica", 9)
    canvas.drawCentredString(A4[0]/2.0, 40, f"Page {doc.page}")
    canvas.setFillColor(SOFT_GREY); canvas.setFont("Helvetica-Oblique", 8)
    canvas.drawRightString(A4[0]-50, 40, "Generated by Mock Paper Generator")
    canvas.restoreState()

def _header(canvas, doc, title: str):
    canvas.saveState()
    canvas.setFont("Helvetica-Bold", 10)
    canvas.setFillColor(SECTION)
    canvas.drawString(50, A4[1]-40, title)
    canvas.restoreState()


# ---------------- Math handling ----------------
INLINE_RE      = re.compile(r"(?:\\\((.*?)\\\)|\$(.+?)\$)")
BLOCK_LINE_RE  = re.compile(r"^(?:\\\[(.*?)\\\]|\$\$(.+?)\$\$|\$(.+)\$)$")
_FRACISH_RE    = re.compile(r"(\\(?:d|t)?frac\b|\\over|\d+\s*/\s*[\da-zA-Z(])")  # detect fractions

def _ocr_normalize(s: str) -> str:
    s = (s.replace("•", "\\cdot").replace("·", "\\cdot").replace("×", "\\cdot")
           .replace("−", "-").replace("–", "-").replace("—", "-")
           .replace("⁄", "/").replace("°", "^{\\circ}"))
    if NORMALIZE_SQUARE_TO_PI:
        s = s.replace("■", "\\pi").replace("□", "\\pi")
    return s

def _sanitize_math(expr: str) -> str:
    expr = expr.strip()
    if expr.startswith("$") and expr.endswith("$"):   expr = expr[1:-1].strip()
    if expr.startswith("\\(") and expr.endswith("\\)"): expr = expr[2:-2].strip()
    return _ocr_normalize(expr)

def _safe_expr(expr: str) -> str:
    s = expr.strip()
    if re.fullmatch(r"_+", s): return s.replace("_", "―")
    return expr.replace("_", r"\_")

def _looks_like_real_math(expr: str) -> bool:
    s = _ocr_normalize(expr.strip())
    if not s: return False
    if any(tok in s for tok in ("\\frac","\\sqrt","\\pi","\\cdot","\\sum","\\int","\\lim",
                                "\\sin","\\cos","\\tan","\\ln","\\log")): return True
    if re.search(r"[_^]", s): return True
    if re.search(r"[=+\-*/><]", s) and re.search(r"\d", s): return True
    if HAS_SYMPY:
        try: parse_latex(s); return True
        except Exception: pass
    words = re.findall(r"[A-Za-z]{3,}", s)
    return len(words) <= 3

def _is_frac(expr: str) -> bool:
    return bool(_FRACISH_RE.search(expr))

_TEMP_IMAGES: List[str] = []

def _render_math_file(expr: str, fontsize: int = BASE_FONTSIZE, dpi: int = 160, pad: float = 0.002) -> str:
    expr = _safe_expr(_sanitize_math(expr))
    tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".png")
    path = tmp.name; tmp.close()
    plt.figure(figsize=(0.01, 0.01)); plt.axis("off")
    try:    plt.text(0.5, 0.5, f"${expr}$", fontsize=fontsize, ha="center", va="center")
    except Exception: plt.text(0.5, 0.5, expr, fontsize=fontsize, ha="center", va="center")
    try:
        plt.savefig(path, format="png", dpi=dpi, bbox_inches="tight", transparent=True, pad_inches=pad)
    except Exception:
        plt.clf(); plt.text(0.5, 0.5, expr, fontsize=fontsize, ha="center", va="center")
        plt.savefig(path, format="png", dpi=dpi)
    finally:
        plt.close()
    _TEMP_IMAGES.append(path)
    return os.path.abspath(path)

def _natural_ratio(path: str) -> float:
    try:
        iw, ih = ImageReader(path).getSize()
        return max(iw, 1) / max(ih, 1)
    except Exception:
        return 1.0

def _img_tag_fit(path: str, base_height_pt: float, max_width_pt: float, shrink_x: float = 1.0) -> str:
    ratio    = _natural_ratio(path)
    width_pt = base_height_pt * ratio * shrink_x
    height_pt= base_height_pt
    if width_pt > max_width_pt:
        scale = max_width_pt / max(width_pt, 1e-6)
        width_pt *= scale; height_pt *= scale
    return f"<img src='{path}' width='{width_pt:.3f}' height='{height_pt:.3f}' valign='bottom'/>"

def _inline_img_tag(expr: str) -> str:
    path = _render_math_file(expr)
    base_h = MATH_IMG_H_FRAC if _is_frac(expr) else MATH_IMG_H
    return _img_tag_fit(path, base_height_pt=base_h, max_width_pt=USABLE_WIDTH*0.90, shrink_x=MATH_H_SHRINK)

def _block_math_paragraph(expr: str) -> Paragraph:
    path = _render_math_file(expr)
    base_h = MATH_IMG_H_FRAC if _is_frac(expr) else MATH_IMG_H
    img  = _img_tag_fit(path, base_height_pt=base_h, max_width_pt=USABLE_WIDTH*0.96, shrink_x=MATH_H_SHRINK)
    return Paragraph(f"<para align='center'>{img}</para>", style_body)


# ---------------- OCR/line cleanup ----------------
_SYMBOLS = r"+\-*/=^(){}\[\]<>,.;:\\|~"

def _is_math_token(tok: str) -> bool:
    t = tok.strip()
    if not t: return False
    if re.fullmatch(rf"[{_SYMBOLS}]+", t): return True
    if re.fullmatch(r"\d{1,8}", t): return True
    if re.fullmatch(r"[a-zA-Z]", t): return True
    if t in {"pi","ln","log","sin","cos","tan","dx","dy","dr","dt","xy","yx","rh"}: return True
    if re.fullmatch(r"[A-Za-z]{2,3}", t) and t.lower() in {"ln","log","sin","cos","tan","min","max"}:
        return True
    return False

def _is_math_line(line: str) -> bool:
    s = line.strip()
    if not s: return False
    toks = [t for t in re.split(r"\s+", s) if t]
    if not toks: return False

    has_operator = bool(re.search(r"[=+\-*/^]", s)) or any(
        k in s for k in ("\\frac","\\sqrt","\\pi","\\cdot","\\sum","\\int","\\lim",
                         "\\sin","\\cos","\\tan","\\ln","\\log")
    )
    if REQUIRE_OPERATOR_FOR_BLOCK and not has_operator:
        return False

    mathish = sum(_is_math_token(t) for t in toks) / len(toks)
    return mathish == 1.0 or mathish >= 0.9

def _join_math_runs(lines: List[str]) -> List[str]:
    if JOIN_MATH_RUNS_MODE == "off":
        return lines

    out: List[str] = []
    i, n = 0, len(lines)
    while i < n:
        if _is_math_line(lines[i]):
            j, segs = i, []
            while j < n and _is_math_line(lines[j]):
                segs.append(lines[j].strip()); j += 1
            joined = " \\, ".join(segs) if JOIN_MATH_RUNS_MODE == "strict" else " ".join(segs)
            joined = re.sub(r"\s+([=+\-*/^,])", r" \1", joined)
            joined = re.sub(r"([=+\-*/^,(])\s+", r"\1 ", joined)
            joined = re.sub(r"\s{2,}", " ", joined).strip()
            out.append(joined)
            i = j
        else:
            out.append(lines[i]); i += 1
    return out

def _coalesce_math_blocks(lines: List[str]) -> List[str]:
    out: List[str] = []; i = 0; n = len(lines)
    while i < n:
        s = lines[i].strip()
        if s == r"\[":
            j = i+1; parts=[]
            while j < n and lines[j].strip() != r"\]": parts.append(lines[j].strip()); j += 1
            if j < n: out.append(r"\[" + " ".join(parts) + r"\]"); i = j+1; continue
        if s == r"\(":
            j = i+1; parts=[]
            while j < n and lines[j].strip() != r"\)": parts.append(lines[j].strip()); j += 1
            if j < n: out.append(r"\(" + " ".join(parts) + r"\)"); i = j+1; continue
        if s == r"$$":
            j = i+1; parts=[]
            while j < n and lines[j].strip() != r"$$": parts.append(lines[j].strip()); j += 1
            if j < n: out.append("$$" + " ".join(parts) + "$$"); i = j+1; continue
        out.append(lines[i]); i += 1
    return out

def _strip_spurious_wrappers(line: str) -> str:
    m = re.fullmatch(r"\$(.*)\$", line.strip())
    if m and not _looks_like_real_math(m.group(1)): return m.group(1).strip()
    m = re.fullmatch(r"\\\((.*)\\\)", line.strip())
    if m and not _looks_like_real_math(m.group(1)): return m.group(1).strip()
    def _repl(mm: re.Match) -> str:
        expr = next((g for g in mm.groups() if g), "")
        return expr if not _looks_like_real_math(expr) else mm.group(0)
    return INLINE_RE.sub(_repl, line)

def _unsquash_safe(line: str) -> str:
    if not ENABLE_UNSQUASH_SAFE:
        return line
    s = line.strip()
    if len(s) >= 32 and " " not in s and re.fullmatch(r"[A-Za-z]+[A-Za-z]+", s):
        s2 = re.sub(r"(?i)(and|the|that|with|when|where|which|for|from|into|onto|over|under)", r" \1 ", s)
        s2 = re.sub(r"(?i)(determine|find|show|discuss|assume|given|formula|minimize|maximize)", r" \1 ", s2)
        s2 = re.sub(r"\s{2,}", " ", s2).strip()
        return s2
    return line

# Gentle punctuation spacing for plain text (not math)
def _fix_missing_punct_spaces(s: str) -> str:
    # Add a space after comma/period only when both sides are letters (avoid 3.14 etc.)
    s = re.sub(r'(?<=[A-Za-z]),(?=[A-Za-z])', ', ', s)
    s = re.sub(r'(?<=[A-Za-z])\.(?=[A-Za-z])', '. ', s)
    # Add a space after a closing parenthesis if stuck to a letter
    s = re.sub(r'(?<=\))(?=[A-Za-z])', ' ', s)
    # Add a space before an opening parenthesis stuck to a word
    s = re.sub(r'(?<=[A-Za-z])\(', ' (', s)
    # Collapse any doubles
    s = re.sub(r'\s{2,}', ' ', s)
    return s


# ---------------- Build ----------------
def build_mockpaper_pdf(
    text: str,
    out_path: str,
    title: str = "Generated Mock Exam Paper",
    source_name: Optional[str] = None,
    is_answer_key: bool = False
):
    raw_lines = text.replace("\r\n", "\n").replace("\r", "\n").splitlines()
    raw_lines = [ _ocr_normalize(s) for s in raw_lines ]
    lines     = _join_math_runs(raw_lines)
    lines     = _coalesce_math_blocks(lines)

    story: List[Union[Flowable, Paragraph]] = []

    # Cover
    story.append(Spacer(1, TOP_MARGIN))
    story.append(Paragraph(title, style_cover_title))
    if source_name:
        story.append(Paragraph(source_name, style_cover_sub))
    story.append(Spacer(1, 10))
    story.append(Paragraph("<b>Instructions:</b> Answer all questions. Show full working.", style_body))
    story.append(PageBreak())

    for raw in lines:
        line = _strip_spurious_wrappers(raw.strip())
        if not line:
            story.append(Spacer(1, 4))
            continue

        # Block math
        m_block = BLOCK_LINE_RE.fullmatch(line)
        if m_block:
            expr = next((g for g in m_block.groups() if g), "")
            if _looks_like_real_math(expr):
                story.append(_block_math_paragraph(expr))
            else:
                story.append(Paragraph(_sanitize_math(expr), style_body))
            continue

        # Inline math
        if INLINE_RE.search(line):
            def _repl(m: re.Match) -> str:
                expr = next((g for g in m.groups() if g), "")
                return _inline_img_tag(expr) if _looks_like_real_math(expr) else _sanitize_math(expr)
            replaced = INLINE_RE.sub(_repl, line)
            story.append(Paragraph(replaced, style_body))
            continue

        # Marks / Answers
        low = line.lower()
        if "mark" in low:
            story.append(Paragraph(line, style_marks)); continue
        if is_answer_key and low.startswith(("answer", "ans:", "solution")):
            story.append(Paragraph(line, style_answer)); continue

        # Heuristic math line
        if re.search(r"[=+\-\^*/><]", line) and _looks_like_real_math(line):
            story.append(_block_math_paragraph(line))
            continue

        # Default text (with gentle punctuation fix + safe unsquash)
        clean = _fix_missing_punct_spaces(_unsquash_safe(line))
        story.append(Paragraph(clean, style_body))

    out = Path(out_path); out.parent.mkdir(parents=True, exist_ok=True)
    doc = SimpleDocTemplate(
        str(out),
        pagesize=A4,
        topMargin=TOP_MARGIN, bottomMargin=BOTTOM_MARGIN,
        leftMargin=LEFT_MARGIN, rightMargin=RIGHT_MARGIN
    )

    try:
        doc.build(
            story,
            onFirstPage=lambda c, d: (_header(c, d, title), _footer(c, d)),
            onLaterPages=lambda c, d: (_header(c, d, title), _footer(c, d)),
        )
    finally:
        # clean temp images
        for p in list(_TEMP_IMAGES):
            try:
                if p and os.path.exists(p): os.remove(p)
            except Exception:
                pass
            finally:
                try: _TEMP_IMAGES.remove(p)
                except Exception: pass

    return str(out)
